## Отчёт по утечкам памяти

### Область проверки

- **Клиент**: React-приложение и игровой движок в `packages/client`
- **Ключевые точки риска**:
  - игровой цикл (`requestAnimationFrame`) в `gameEngine`
  - обработчики событий (`addEventListener`) на `document` и `canvas`
  - таймеры (`setTimeout`)
  - сервис-воркер

### Найденные утечки и исправления

- **Проблема: неочищенный игровой цикл `requestAnimationFrame`**
  - **Где**: компонент `Game` (`packages/client/src/pages/game/Game.tsx`), класс `GameEngine` (`packages/client/src/gameEngine/GameEngine.ts`)
  - **Суть утечки**:
    - `GameEngine` в конструкторе запускает бесконечный игровой цикл через `requestAnimationFrame` (`startRendering`).
    - В React-компоненте `Game` экземпляр `GameEngine` создаётся в `useEffect`, но в функции очистки эффекта вызывался `gameEngine?.destroy()`, где `gameEngine` — состояние.
    - Из-за особенностей замыканий в React в функции очистки оказывалось старое значение `gameEngine` (на момент монтирования эффекта), которое могло быть ещё `null`. В результате при размонтировании компонента игровой цикл мог не быть остановлен, а ссылка на `renderLoop` и экземпляр движка продолжали жить до перезагрузки страницы.
  - **Что делает метод `destroy`**:
    - В `GameEngine.destroy` вызывается `cancelAnimationFrame` для сохранённого `animationId`, что корректно останавливает цикл и позволяет сборщику мусора освободить ссылки на `GameEngine`, `PageManager`, `ActivityManager`, `PlayerManager` и связанные объекты.
  - **Исправление**:
    - Функция очистки эффекта теперь вызывает `engine.destroy()`, используя локальную переменную `engine`, созданную внутри эффекта, а не состояние `gameEngine`.
    - Это гарантирует, что именно тот экземпляр `GameEngine`, который был создан этим эффектом, будет корректно остановлен при размонтировании компонента или смене `state`.
  - **Риск для логики игры**:
    - Изменение затрагивает только момент размонтирования/пересоздания компонента `Game`.
    - Логика самой игры (отрисовка, обновление состояний, обработка смерти игрока) не изменена.
    - Поведение во время активной игры остаётся прежним, утечка устраняется только при выходе со страницы игры или её повторном открытии.

### Потенциальные источники утечек, которые проверены

- **Обработчики fullscreen в `Header` и `fullscreenApi`**
  - Используются `document.addEventListener` и `document.removeEventListener` в `useEffect`/`cleanup`, а также пара методов `addChangeListener`/`removeChangeListener` в `fullscreenApi`.
  - На момент проверки подписчики добавляются и снимаются симметрично, утечек не обнаружено.

- **Таймеры `setTimeout`**
  - В `Header` для скрытия сообщения используется `setTimeout` с последующим `clearTimeout` в функции очистки эффекта.
  - В страницах форума `CreateTopicPage` и `TopicPage` `setTimeout` используется внутри `Promise` для имитации задержки в одном асинхронном вызове — такие таймеры отрабатывают один раз и не создают долгоживущих ссылок.
  - Утечек не выявлено.

- **Обработчики событий на `canvas` в `PageManager`**
  - События `mousemove` и `click` вешаются на экземпляр `canvas` внутри конструктора `PageManager`.
  - При корректной остановке игрового цикла (`destroy`) и размонтировании React-компонента:
    - канвас удаляется из DOM вместе с контейнером,
    - ссылки на `GameEngine`/`PageManager` становятся недостижимыми (после отмены `requestAnimationFrame`),
    - движок и его менеджеры могут быть собраны сборщиком мусора вместе с обработчиками.
  - При исправленном очищении игрового цикла дополнительных утечек здесь не ожидается.

- **Сервис-воркер**
  - Обработчики (`install`, `activate`, `fetch`) регистрируются в глобальном контексте сервис-воркера, что является штатным поведением.
  - Эти обработчики живут столько же, сколько и сам сервис-воркер; утечек, связанных с многократной регистрацией или забытыми слушателями, не обнаружено.

### Итог

- **Обнаруженная и исправленная проблема**: возможная утечка памяти, связанная с неостановленным игровым циклом `requestAnimationFrame` при размонтировании компонента `Game`.
- **Текущий результат проверки**:
  - После исправления проблем с очисткой игрового цикла дополнительных очевидных утечек памяти (таймеры, обработчики событий, сервис-воркер) в кодовой базе не выявлено.
  - Логика приложения и игры не изменена, поправлена только корректная остановка ресурсов при закрытии/переключении страницы игры.


